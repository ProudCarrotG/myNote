
# 中断 
- 请求系统服务
- 实现并行工作
- 处理突发事件
- 满足实施要求

	是实现多任务的基础

	中断源：能够引起中断发生的事件
## 分类 
### 从性质和激活手段
- 强迫性 （由某种事故或外部请求信息引起
	- 机器故障终端事件
	- 程序性中断事件  ----内中断
	- 外部中断事件
	- 输入输出中断事件
- 自愿性 （正在运行的程序所期待的事件
	- 访管中断（系统调用）
### 按事件来源和实现手段
- 硬中断  
	- 外中断（中断、异步中断）
		- 吃饭咽下一口之后才停下吃饭行为（等待当前命令执行完毕），喊老师好（中断处理），吃饭被停下
	- 内中断（异常、同步中断）
		- 吃饭被噎住马上停下吃饭行为，当前命令未执行完毕，立即执行中断处理
- 软中断
	- 信号
	- 软件中断


## 处理中断
- 发现中断源
- 保护现场 （保存PC、寄存器的值等）
- 转向处理中断、异常事件的处理程序
- 恢复现场

# 进程
**可并发执行的程序**在某个**数据集合上**的**一次**计算活动，也是操作系统进行资源分配和保护的**基本单位**
进程是一个既能用来共享资源，又能描述程序并发执行过程的一个基本单位

与程序区分，进程是指程序执行，执行一次即产生一个进程或多个进程

刻画系统的**动态性**

|      程序      |       进程       |
|:--------------:|:----------------:|
|      静态      |       动态       |
|      辅存      |   主存（内存）   |
|      永久      |       暂时       |
|  **1个**程序   | 产生**多个**进程 |
| **多个**程序被 | **一个**进程共享 |

- 结构性
- 共享性
- 动态性
- 独立性
- 制约性
- 并发性

![[Pasted image 20231008095143.png]]


	五态图

## 挂起
暂时不参与低级调度，释放其占有的资源
挂起包括两个操作：挂出、挂回

	七态图

- 即将被执行的不能被挂起


## 进程控制块 PCB
一个进程对应一个PCB
各种数据变量的集合
由操作系统创建
进程结束后os回收pcb
对进程的管理 ＝ 对pcb的管理 （相当于指针
包含信息：
1. 标识信息
	1. 相对固定
2. 现场信息
	1. 动态
	2. 各种寄存器变量
3. 控制信息
	1. 存储状态（就绪、等待等）

## 缺点
切换开销大
通信代价大
并发度不高
不适应计算和分布并行计算的要求
不符合客户/服务器计算的要求
需要申请资源

# 线程
因为[[#进程#缺点]]，所以引入线程，从进程中优化
不需要申请资源，直接进行任务调度
线程隶属某个进程，一个进程可以申请多个线程
资源由进程争夺，争夺后分配给线程，资源使用后进程回收

# 进程调度

从进程开始到结束一般经过三个调度
- 高级调度/**作业**调度/长程调度
- 中级调度/[[#挂起]]（非必须）
- 低级调度/**进程**调度/短程调度


## !!周转时间
批处理用户从作业提交给系统开始到完成的时间**间隔**称为周转时间
周转时间有且只有一个
方便调度算法对进程的性能评测  重要指标！
周转时间越短，性能越好

## 吞吐率
单位时间内处理的作业数

## 公平性
确保每个进程都能获得合理的CPU份额或其他资源，不会出现饥饿现象

[[饥饿现象]]

## 调度算法
	- 到达时间:进程\线程申请的时间
	- 开始时间:进程\线程的开始运行时间
	- 完成时间:结束运行的时间
	- 周转时间:完成时间-到达时间
	- 带权周转时间:周转时间/运行消耗时间
	- T(平均周转时间)
	- W(平均带权周转时间)
	- 忽略时空损耗,即进程切换**无时间损耗**

[[优先级]]
1. 非剥夺式(非抢占)
	1. 高优先级进程\线程剥夺低优先级的
	2. 进程\线程时间片用完可以剥夺[[时间片]]
	3. 算法
		1. 先来先服务(FCFS)
			1. 先来先到,后来的等先来的处理完
		2. 短作业优先(SJF)(shortest job first)
			1. 先做运行时间短的,注意各作业的**到达时间**,没到达的作业就算运行时间短也不能先运行
			2. 避免短作业出现[[饥饿现象]]
		3. 高响应比优先调度(HRRF)
			1. $ss(响应比R_p = 1+等待时间/运行时间)$
				1. 反应的是一个各个作业的相对与全局的饥饿程度,让当前最饥饿的作业先运行[[饥饿现象]]
			2. 偏向于短作业,但是可以防止长作业出现饥饿
			3. 响应比实时更新
				1. 开销**成本高**,每次选择作业都要进行一次计算,所以使用比较少
		4. 高优先级调度(HPF)(非抢占式)
			1. 按作业优先度高低,优先级高的先做
				1. [[优先级]]

1. 剥夺式(抢占)
	1. 正在执行的进程,如果发现有新的作业,将进行竞争,可能会产生中断,将资源让出给竞争胜利的作业
	2. 算法:
		1. 最短剩余时间优先(SRTF)
			1. 按照进程当前剩余时间长短,依次调度执行
				1. 出现两个作业的剩余时间相同时,此时的选择可以体现操作系统的**优化程度**.一般选择当前正在执行的程序,可以减少作业的中断次数.
			2. 一次作业可能不会一次执行完毕,可能出现断断续续的执行
		2. 高优先级调度算法
			1. 优先级高的先执行
				1. 优先级:[[优先级]]
		3. 时间片轮转算法[[时间片]]
			1. 按照时间片大小,各进程轮流使用cpu,依次调度执行
			2. 每一个作业只执行一个时间片的大小,新到达的可以先在到达时间片运行
2. 两级调度联合考虑