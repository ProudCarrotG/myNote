# 第二章 数据信息的表示

## 数的机器码表示

-    真值：
    -   有`+/-`的二进制数
    -   机器不能识别`+-`, 所以用`0/1`表示`+/-`
        -   定点小数表示: $x = +0.1001 \ or \ x = -0.1001$
            -   整数部分只能为0
        -   定点整数表示: $x = +1001 \ or \ -1001$
            -   没有小数点即小数部分

-   机器码
    -   将符号和数值一起编码表示的二进制数称为**机器码**。
    -    常用机器码：**原码、** **反码、 补码、移码** 



### 原码

-   定点小数$x_0.x_1x_2...x_n$(共**n+1**位, $x_0$为符号位)

$$
[x]_原 = \begin{cases}x\\1-x = 1+|x|\end{cases}\qquad\begin{align*}  &0<=x<1 \\  &-1<x<=0\end{align*}
$$

>   定点小数: 没有整数部分, 默认整数部分为0

 *x*＝+0.1001，则$[x]_原＝0.1001$

 *x*＝-0.1001，则$[x]_原＝1.1001$

-   定点整数$x_0x_1x_2...x_n$

$$
[x]_原 = 
\begin{cases}
x\\
2^n-x=2^n+|x|
\end{cases}
\qquad
\begin{align*}
0<=x<2^n\\-2^n<x<=0
\end{align*}
$$

 *x*＝+1001， 则$[x]_原＝01001$　 

 *x*＝-1001， 则$[x]_原＝11001$ 

式中$[x]_原$是机器数, $x$是真值

### 反码

反码其**符号位**和原码相同, 真值是正数时，反码与原码相同；真值是负数时，反码**数值位**为真值**数值位**取反。

>   符号位不变！！！



### 补码

 补码又称为模`2`的补码。

$直接取原来的二进制码,符号位为0 \qquad x>0$

$[x]_补 = [x]_反+1\qquad \qquad x<0$ 

-   求法(适用于负数)

    -   直接求解, 取反加一

    -   扫描法, 从最右侧向左扫描，直到找到第一个1，该数位内容不变，其左侧所有数值位取反，其他数值位不变，符号位为1。

![image-20230606210642444](计组.assets/image-20230606210642444.png)

补码中的位移很好用, 可以快速计算/2 /4等操作

补码的位数扩展, 在最左侧补位, 内容为符号位

符号位参与运算

### 变形补码

  变形补码也称为双符号位补码，或模4补码。
$$
定点小数：
[x]_补=\begin{cases}
x\\
4+x
\end{cases}
\qquad
\begin{align*}
0<=x<1\\-1<=x<=0
\end{align*}
\qquad
(mod\ 4)
$$

定点整数中n为数值位位数

$$
定点整数：[x]_补=\begin{cases}
x\\x^{n+2}+x
\end{cases}
\qquad
\begin{align*}
0<=x<2^n\\-2^n<=x<=0
\end{align*}
\qquad 
(mod\ 2^{2^{n+2}})
$$

求法: 

其实就是在补码的基础上, 符号位变成两位, 数值位不变

### 移码

  **移码通常用于表示浮点数的阶码。**

移码将负数部分变成正数

[ey]: 8位移码表示的机器数为数的真值在数轴上向右平移了**128**个位置


![image-20230606211846739](计组.assets/image-20230606211846739.png)

[ey1]:  x = +10101

​	$[x]_移 = 2^5+10101=1,10101;$

[ey2]:  x = -10101

​	$[x]_移 = 2^5+x=2^5-10101 = 0,01011$

[ey3]: 0的移码是唯一的

$[+0]_移=[0]_移 = 100...00$

>   移码中, 符号位`1`为正, `0`为负

数`x`的补码和移码进行转换时, **数值位不变, 符号位取反**

### IEEE754浮点数标准

![image-20230606223557775](计组.assets/image-20230606223557775.png)

![image-20230606223621387](计组.assets/image-20230606223621387.png)

**S**：尾数符号，`0`正`1`负；

**M**：尾数1,纯小数表示,小数点放在尾数域的最前面。 一般采用原码或补码表示。 $\frac{1}{2}<=M<=1$

**E**：阶码，采用“移码”表示;阶符采用隐含方式，即采用“移码”方法来表示正负指数。

-   规格化:
    -   ![image-20230606224258410](计组.assets/image-20230606224258410.png)

### 浮点数表示

二进制数N，可以表示为：
$$
N=R^E\times M=2^E\times M = 2^{\pm e}\times(\pm m)
$$

>   M: 尾数，是一个定点小数；
>
>   E：阶码，是一个定点整数
>   $$
>   e=\begin{cases}
>   E=127\\E-1023
>   \end{cases}
>   \qquad
>   \begin{align*}
>   32位浮点数\\
>   64位浮点数
>   \end{align*}

>   $$
>   
>
>   R：基数，对于二进制数值的机器是一个常数，一般为`2/8/16`
>
>   







# 第四章 存储系统存储结构

使用双向译码，即纵向一个译码器，横向一个译码器，若想选择存储单元`(x,y)`，需要横向译码器输出第`x`位为高电平, 纵向译码器输出第`y`为为高电平, 满足两个条件才能选择单元`(x, y)`
    
![image-20230516082717578](https://raw.githubusercontent.com/ProudCarrotG/tuChuang/main/image-20230516082717578.png)

##   大端方式 小端方式

**1)大端模式：**
低地址 -----------------> 高地址
0x12  |  0x34  |  0x56  |  0x78

**2)小端模式：**

低地址 ------------------> 高地址
0x78  |  0x56  |  0x34  |  0x12

##   存储规格

存储芯片的规格：**m×n** 位

​    **m**：字, 用来描述该芯片可寻址的范围，也可以表述片内译码需要的地址线数量（log2 m）。

>   共m个存储单元

​    **n**：表示该芯片位宽，即一次可读/写的数据位数

##   扩展

>   扩展容量的方法, 可以从3个方面来进行扩展

1.   位扩展

扩展位宽, 即一次可读/写的数据位数. 通过增加存储芯片的个数来实现. 若一个芯片的位宽为`x`, 一个芯片存储数据的低`x`位, 读/写数据时所有芯片同时进行, 再将数据进行组合

存储系统位宽为 `N`位，若使用`k`位芯片，$k<N$，需$(N/k)$个芯片

![image-20230516084407138](https://raw.githubusercontent.com/ProudCarrotG/tuChuang/main/image-20230516084407138.png)

2.   字扩展

扩展寻址范围, 通过译码器选择对应的芯片

>   译码器选择芯片称为**片间寻址**
>
>   其他的地址线选择芯片内的存储单元地址称为**片内寻址**

![image-20230516084556853](https://raw.githubusercontent.com/ProudCarrotG/tuChuang/main/image-20230516084556853.png)

3.   字位同时扩展

![image-20230516084629876](https://raw.githubusercontent.com/ProudCarrotG/tuChuang/main/image-20230516084629876.png)

##   并行主存系统

1.   -   具有两组相互独立的读写控制线路
    
     -   两组读写控制线路可以并行操作

     -   端口地址不相同，无冲突，并行存取

     -   端口地址相同，读写冲突，无法并行存取


​          

![image-20230516085129403](https://raw.githubusercontent.com/ProudCarrotG/tuChuang/main/image-20230516085129403.png)

2.   编址方式

![image-20230516085307555](https://raw.githubusercontent.com/ProudCarrotG/tuChuang/main/image-20230516085307555.png)

##   相关数据计算

因为引入了并行主存系统的**交叉方式**, 并且因为cpu芯片发送读/写命令后**总线传送命令的传送**需要花费一定的时间, 存储体**接收/发出**数据也需要一定时间; 又因为一个存储体中有多个数据, 而一个存储体同时只能读/写一个数据. 为了缩短读取连续数据**总的**读写时间, cpu的**读/写命令**可以在上一个命令完成后, 未接收数据前**发出**

如图, 图中纵坐标表示读取的**位**, 横坐标表示**时间**, `M`表示**系统中完成一个数据读/写花费的总时间(发送命令+数据接收/发出)**

![image-20230516090005901](https://raw.githubusercontent.com/ProudCarrotG/tuChuang/main/image-20230516090005901.png)

1.    相关变量

      1.    `T`: 模块存取一个字的存储周期
      2.    $\tau$: 总线传送周期
      3.    `m`: 存储体个数
      4.    `n`: 按地址顺序连续读取`n`个字
      5.    `w`: 位

2.    计算

      1.    按地址顺序连续读取`n`个字, **交叉**存储器需要的时间:
            $$
            t_{交} = T+(n-1)\tau
            $$

      2.    按地址顺序连续读取`n`个字, **顺序**存储器需要的时间:

      $$
      t_{顺} = nT
      $$

      3.   交叉存储度: $T/\tau$

## 带宽

一个存储周期中, 能够传输的信息总量的速率

1.   按**地址顺序**连续读`n`个字, 传递的信息总量为

$$
q= w*n
$$

2.   带宽
     $$
     W_{顺}=\frac{q}{t_{顺}}=\frac{w*n}{nT} = \frac{w}{T}\\
     W_{交}=\frac{q}{t_{交}}=\frac{w×n}{(T+(n-1)τ)}
     $$

## 高速缓冲存储器(Cache)

 容量小, 但速度比主存高得多, 介于`cpu`与`主存`之间. 它是为了**解决CPU和主存之间速度不匹配**而采用的一项重要技术。

>   分块: 将主存中连续的一定长度的地址区分开称为块

**Cache**与主存之间的**数据交换是以块为单位**。即一次性将主存中一段连续的数据放入**Cache**中

-   命中: 若**cpu**需要读取的数据在Cache中存在, 则为命中(`hit`), 否则为未命中(`miss`)
-   命中率: $h = \frac{N_c}{N_c+N_m}$
-   $N_c$: 表示Cache完成存取的总次数
-   $N_m$: 表示主存完成存取的总次数
-   平均访问时间(等效访问时间)$t_a = ht_c+(1-h)t_m$ 
    -   $t_c$表示命中时的Cache访问时间
    -   $t_m$表示未命中时的主存访问时间
    -   $1-h$表示缺失率
-   访问效率$e=\frac{t_c}{t_a} = \frac{1}{h+(1-h)r}$

### 地址映射

利用某种方法或规则将主存块定位到Cache称为**地址映射**。

>   块指主存中一组连续的数据
>
>   区指主存中一组相联的块

#### 全相联

cache的缓冲区按顺序存储主存中的块区，存满cache之前都不删除数据，利用算法来处理cache满时的数据删除

cache按行存放，一行的大小为一个区，一次存放一行

存储容量=查找表表项大小$\times$行数

cache中每一行都有一个**有效位**标志和**tag**标志，**有效位**表示缓冲区内某一行有存储数据，**tag**存放这一行的数据的**块标志**

>   主存分为n个块，每个区都有一个独特的块标志
>
>   每个块的大小由cache的**行容量**决定

载入过程：

-   判断cache中**有效位为1**的行，查找其中的**tag**值
    -   如果存在tag值与目标区标志相同，则为**命中（hit）**，直接将cache中的数据传输至cpu
    -   如果不存在tag值与目标区标志相同，则为**未命中miss**，将主存中的**块按顺序**放入cache中，修改行的有效位和tag
-   ![image-20230608085252152](计组.assets/image-20230608085252152.png)

#### 直接相联映射

大致步骤和全相联映射相同。不同的是先将主存中的地址分为n个区，一个区中第`i`块只存放在cache中对应的第`i`行中

>   将主存分为n个区，每个区有m个块
>
>   区中块的数量由cache行数决定

![image-20230608090102510](计组.assets/image-20230608090102510.png)

![image-20230608090120981](计组.assets/image-20230608090120981.png)

#### 组相联映射

为前两种方法的结合

将cache的多行分为一组，主存中分区, 区中的第`i`个块只存放在cache中的第`i`**组**中, 组内采用全相联映射法

![image-20230608091018104](计组.assets/image-20230608091018104.png)

![image-20230608091053579](计组.assets/image-20230608091053579.png)

---

# 指令系统

格式:

| 操作码OP | 地址码A |
| :------: | :-----: |

指令格式: 用二进制代码表示指令的结构形式

操作码字段: 解决进行何种操作的问题

地址码字段: 解决处理什么操作数的问题;

寻址方式字段: 决定地址码中操作数存放的位置和访问方式



-   指令字长度: 指令中包含二进制代码的位数, 或称为**指令字长**
-   指令字长与机器字的长度有关: 单子长, 双子长, 半字长
    -   指令字越长, 地址码长度越长, 可直接寻址空间越大
    -   指令字越长, 占用空间越大, 取指令越慢



-   三地址指令

| op   | A1   | A2   | A3   |
| ---- | ---- | ---- | ---- |

功能二: A2 OP A3 -> A1 		// A2与A3操作后的结果存放至A1中

-   二地址指令

| op   | A1   | A2   |
| ---- | ---- | ---- |

功能: A1 OP A2 -> A1

-   一地址指令

| op   | A    |
| ---- | ---- |

功能1: OP A -> A 			

功能2: AC OP A -> AC			//AC为某个特定的寄存器

-   零地址指令

| op   |      |
| ---- | ---- |



## 扩展操作码的指令格式

![image-20230608093211708](计组.assets/image-20230608093211708.png)

几种指令的指令字长相同, op的长度不同, 系统通过不同的op标志来判断指令是何种类型

[ey]: 三地址指令有7条, 三地址指令的op长度为3, $000-110$为三地址指令的标志;若二地址指令有3条, 则需要op长度为2, $11100 - 11110$为二地址指令的标志, $11111\times$为一地址指令标志

[ey]: 

![image-20230608093751140](计组.assets/image-20230608093751140.png)

![image-20230608093904340](计组.assets/image-20230608093904340.png)

>   编码方案: 每种地址指令的op标志占用的长度
