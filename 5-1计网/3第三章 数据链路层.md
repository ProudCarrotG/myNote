#计网

传输单位：帧 （Frame）

结点（node）： 网络中的**主机**和**路由器**

链路（link）： 通信路径上连接相邻节点的通信信道，中间没有其他的交换节点。一条链路只是一条通路的一个组成部分

数据链路（data link）： 在一根线路上传输数据，还要有一些**必要规程**控制数据传输

规程：通信**协议**

数据链路层协议：定义了一条链路的两个节点间交换数据的数据单元**格式**，以及节点发送和接收数据单元的**动作**
> 使用适配器 (网卡)来实现协议的硬件和软件
> 一般的适配器都包括了链路层和物理层的功能

点到点 (point to point): (数据链路层)
通信: 相邻节点间一条链路的通信

>端到端 (end to end): (在网络层传输层)
从源节点到目的节点的通信; 会有多条链路构成



---
#  3.1 

## 3.1.1 提供给网络层的服务
1. 向网络层提供一个定义良好的**服务接口**
	1. 数据链路 = 物理链路 (物理信道) + 通信规程 (协议)
	2. 三种方式
		1. **无确认的无连接服务**
			1. 定义: 源机器向目标机器发送独立的帧, 目标机器并不会对这些帧进行确认
			2. 特点: 实现不需要建立逻辑链接, 事后也不用释放逻辑链接; 不用试图去检测丢帧情况, 也不会去试图恢复丢失的帧
			3. 应用场景:
				1. 错误率很低的场合
				2. 实时通信, 如语音传输 (对速度有一定要求的)
		2. **有确认的无连接服务**
			1. 定义: 发送的每个帧都需要**单独确认**. 一个帧在指定的时间间隔内没有到达, 则将再次发送该帧
			2. 特点: 没有事先建立或事后释放的逻辑链接
			3. 措施: 目标机器应该向源机器发送确认帧
				1. **接收正确的帧**:ACK
				2. **接收到错误的帧**:NAK
				3. **超时**:Resend
			4. 应用场景: 不可靠的信道, 如**无线信道**
		3. **有确认的有链接服务**  (有确认的面向连接服务)
			1. 定义: 源机器和目标机器在传输任何数据之前, 都要**建立**连接, 发送的每个帧都要被**编号**, 数据链路层确保每一个帧都会**真正被**接收方**收到**. 此外, 他还保证每个**帧只能接收一次**, 并且所有的帧都**按正确的顺序被接收**
			2. 三个阶段
				1. 建立连接
				2. 传输帧
				3. 释放连接
			3. 特点:
				1. 没有错误的帧
				2. 没有一样的帧
				3. 有顺序的
2. 处理传输错误 ---- 错误控制
	1. 物理层中传输介质的噪声, 所以错误不可避免, 交由链路层来控制错误
3. 调解数据流, 确保慢速接收方不会被快速发送方淹没----流量控制
	1. 发送方发送速度太快, 接收方来不及接收容易出错, 会导致数据丢失 ^1998 a 5

## 3.1.2 成帧
将 01 比特流打包成一段一段的.
1. 为什么成帧
	1. 提高传输效率
	2. 差错控制
2. 帧同步
	1. 以帧为单位进行传送, 指出帧的开始和结束
3. 方法:
	1. Byte count **字节计数法**
		1. 利用头部的一个字段, 来表示该帧中的字节数
			1. 只用第一个字段来表示帧的范围
		2. 计数值可能因为一个传输错误而被弄混
			1. 一个计数值错了, 后面的就会全错
	2. Flag bytes with byte stuffing **字节填充的标志字节法**
		1. 标志字节: 用一个字节"FLAG**字节**"来作为起始和结束
			1. 两个 flag 字节来框出一个帧的范围
		2. 填充字节: ESC 转义**字节**  类似于 `\n` `\\`
			1. 因为 flag 可能还会出现在帧的内容之中, 所以需要一个转义字节
	3. Flag bits with bit stuffing **比特填充的标志比特法**
		1. 方法: 每个帧的开始和结束由一个特殊的比特模式, 如 `01111110` ^8 b 15 ec
			1. 该标志比特可能会出现在帧的内容之中
		2. 填充比特: 
			1. 五个连续的 `1` 后面加 `0`
				1. 样例 1:
				2. 原始内容 `0111111011`
				3. 线路内容 `01111101011`
				4. 接收 `0111111011`
				5. 样例 2:
				6. 原始内容 `110101111101011111101011111110`
				7. 线路内容 `110101111100101111101010111110110`
				8. 线路上完整内容: 在线路内容的头和尾加上标志比特[[3第三章 数据链路层#^8b15ec]]
	4. Pyysical layer coding violations

## 3.1.3 差错控制
1. 原因: 噪声
2. 错误类型:
	1. 数据帧出错
	2. 数据帧丢失
3. 噪声:
	1. 白噪声: 随机错误, 单个出现
	2. 冲击噪声: 突发错误, 密集出现
4. 措施
	1. **避错**: 采用高档设备或介质
	2. **容错**: 发生错误时, 用某种方法检测与纠正
5. 检测和纠正: 数据之外添加冗余编码
	1. 检错码: 通过编码检查能自动发现差错 ^d 46 c 40
		1. 比较简单, 出错之后直接重新传输帧
	2. 纠错码: 除了能知道出错, 还能知道错误发生的位置
		1. 更加复杂, 代价更大
6. 措施: 奇偶校验水平垂直奇偶校验, crc 校验等
	1. 奇偶校验码: 是通过增加冗余位来使得码字中 `1` 的个数保持奇数或偶数的编码方法, 是一种**检错码**   [[3第三章 数据链路层#^d46c40]]
		1. 只能纠正一位错误 (错两位的话奇偶性质不变)


## 3.1.4 流量控制
1. 问题: [[3第三章 数据链路层#^1998a5]]
2. 方法:
	1. 基于**反馈**的流量控制
	2. 基于**速率**的流量控制



## 主要功能
通过一些协议, 在不太可靠的物理链路上实现可靠的数据传输
1. 链路管理
2. 数据成帧
	1. 从 01 比特通过规则成帧
3. 差错控制
4. 流量控制
5. 透明传输
6. 寻址
7. (介质访问控制)(第四章)



---
#  3.2 差错检测和纠正
反正错误不可避免, 理由太长不计了, 大概就是介质什么的问题
## 3.2.1 (重要)检错码
1. 添加冗余信息, 接收方只能推断出有错误, 然后让发送方重传

### 奇偶校验
1. 数据后面加上**一个奇偶位**, 保证码中 `1` 的个数为偶数或奇数
2. 只能检查一位错误
### CRC（循环冗余校验）
#考 
1. 检错能力强大，实现简单，使用广泛
2. **多项式**：将位串中的每一位看成是一个多项式的系数，则一个位串对应一个多项式，这个多项式被称为该**位串的多项式**
3. 模 2 运算 ^8 cfdde ^dfffd 4
	1. 加法不进位，减法不接位，除法中的减法仍采用模 2 运算
4. 生成多项式 $G(x)$：
	1. 双方**必须商定**一个生成多项式
		1. 对应一个位串，注意最低为对应 **0 阶**
		2. 自定的（题目给出）
		3. 常用的四个**国际标准**：
			1. CRC-12 = 1100000001111
				1. $x^{12}+x^{11}+x^3+x^2+x+1$
			2. CRC-16 = 1100000000000011
			3. CRC-CCITT = 1000100000010001
			4. CRC-32 = 
	2. 最高位与最低位系数必须为 $1$
	3. 在帧的尾部附加一个**校验和**（冗余码），使得附加之后的帧所赋予的多项式能够被 $G（x）$ 除尽。当接收方收到后，用生成多项式除一下，若不能够**整除**，则出错
5. 算法：
	1. 在数据后加上 $r(G(x)的阶为r)$ 个 $0$，对应多项式为 $x^rM(x)$
		1. R 是生成多项式最高位的阶数
	2. 用 $x^rM(x)$ 除以 $G(x)$，得到余数 $r(x)$
		1. 使用模 2 运算 [[#^dfffd4]]
		2. 位数够就商 1，位数不够就商 0
	3. 将 $x^rM(x)$ 减去 $r(x)$ 得到**发送序列**
		1. 模 2 运算，减法加法的运算结果都一样
		2. 注意：余数不是冗余码；
		3. **冗余码**的位数是 `r` 位，需要补 `0`，位数与生成多项式的**阶**相关
6. **接收方把收到的数据进行校验后才知道是否出错**


## 3.2.2 纠错码
能直接推断出错了什么

### 海明码
```
海明码（Hamming code）是一种用于检测和纠正数据传输中错误的编码技术。它是由美国数学家理查德·W·海明（Richard W. Hamming）于20世纪中期提出的，用于改进数字通信系统的可靠性。

海明码的主要目的是在数据传输过程中检测并纠正单个比特的错误。这对于在数字通信中具有重要意义，因为在数据传输过程中，由于各种原因，比特可能会出现错误。海明码可以帮助检测这些错误，并在可能的情况下自动修复它们。

海明码的工作原理如下：
1. 将要传输的数据按照一定的规则进行编码，通常会在原始数据中添加一些冗余位。
2. 编码后的数据包含了原始数据和冗余位，使得可以检测和纠正错误。
3. 在接收端，对接收到的数据进行解码，利用冗余位检测错误，如果发现错误，可以通过纠正码来修复错误。
4. 如果错误超出了码字能够纠正的范围，就需要进行重传或其他错误处理操作。

海明码的一个常见应用是在计算机内存中，以检测和纠正内存中的位错误。它还被广泛用于数字通信和数据存储系统中，提高了数据的可靠性。

不同类型的海明码可以用于不同的应用，具体的参数和纠错能力可以根据需求进行调整。这种编码技术在信息科学和通信领域中有广泛的应用。
```
---
#  3.3 基本数据链路层协议
```
//.h
#define MAX_PKT 1024 //以字节为单位确定数据包大小

typedef enum {false, true} Boolean; //布尔类型
typedef unsigned int seq_nr; // sequence和ack数量
typedef struct{unsigned char data[MAX_PKT];}packet; // packet definition
typedef enum{data, ack, nak} frame_kind; //frame_kind definition

typedef struct{   //frames are transported in this layer
	frame_kind kind;  // what kind of a frame is it?
	seq_nr seq;  // sequence number
	seq_nr ack;  //acknowledgement number
	packet info;  //the network layer packet
}frame;


//wait for an event to happen;return its type in event.
void wait_for_event(event_type *event);

//fetch a packet from the network layer for transmission on the channel.
void from_network_layer(packet *p)

//deliver information form an inbound frame to the network layer
void to_network_layer(packet *p)

//Go get an inbound frame from the physical layer and copy it to r
void from_

void to_physical_layer(frame *s);

void start_timer(seq_nr k);

void stop_timer(seq_nr k);

void start_ack_timer(void);

void stop_ack_timer(void);

void enable_networt_layer(void);

void disable_network_layer(void);

#define inc(k) if (k<MAX_SEQ) k = k+1 ……
```

## 3.3.1 一个乌托邦式的单工协议（协议一）
1. 两个假定（理想情况）
	1. 链路是理想的传输信道，不会出现数据出错或丢失（无差错问题）
	2. 不管发送方发送多少数据，接收方总是来得及收下，并上交主机（无流量问题）
	3. 该情况下数据链路层不需要做差错控制和流量控制
	4. 发送方：循环从网络层获得 packet，封装成 frame 发送到物理线路上（封装）
	5. 接收方：循环从物理层获得 frame，取出 packet 交给网络层（解封装）
``` 
#include"乌托邦.h"

void sender(void){
	frame s;
	packet buffer;
	while(true){
		from_network_layer(&buffer);//取包
		s.info = buffer; // 封装
		to_physical_layer(&s); // 发送
	}
}

void reveiverl(void){
	frame r;
	event_type event;
	while(true){
		wait_for_event(&event); // 等待
		from_physical_layer(); //取帧
		to_network_layer(&r.info); //上交
	}
}
```

## 3.3.2 无错信道上的单工停-等式协议（协议二）
1. 去掉第二个假设：链路不出错，但可能流量不匹配
2. 解决方案：
	1. 插入时延；时延大小选择困难，且变化
	2. 让接收方提供反馈信息
		1. 发方：每发一帧，停止下来
		2. 收方：每收到一帧，上交网络层，再发一个确认给发方
		3. 发方：收到确认，再发下一帧
3. ACK 机制：确认机制

``` 
#include"协议二.h"

void sender(void){
	frame s;
	packet buffer;
	event_type event;
	while(true){
		from_network_layer(&buffer);//取包
		s.info = buffer; // 封装
		to_physical_layer(&s); // 发送
		wait_for_event(&event); //等待接收方确认
	}
}

void reveiverl(void){
	frame r,s;
	event_type event;
	while(true){
		wait_for_event(&event); // 等待
		from_physical_layer(); //取帧
		to_network_layer(&r.info); //上交
		to_physical_layer(&s); //发送确认收到信息（哑帧，没有任何数据，只有信号）
	}
}
```

## 3.3.3 有噪声信道上的单工停-等式协议（协议三）
1. 去掉两个假设
	1. 要差错控制
	2. 要流量控制
2. 问题 
	1. 数据帧丢失
		1. 超时重传 $T_{out}$
			1. RTT 往返时延（$T_{out} = T_{sent} + RTT$）
				1. 数据一来一回的时间 = RTT
				2. 作图法 ![[assets/停-等协议的作图法计算.jpg]]
				3. [[0名词解释/传播时延]]
	2. 确认帧丢失
		1. 帧编号
			1. 确认帧和数据帧都进行编号
			2. 得到相同编号的数据帧时，丢弃帧，传输相同编号的确认帧
			3. 目的：让接收方能够区分帧是新的帧还是旧的
			4. 对于 stop-and-wait 协议：一次只发送一个帧，序号只需要一位，用于标记当前帧和下一个帧 （0，1）


```
//初始化

发送方：{
	//初始化数据帧编号为0
	取包
	while（1）{
		封装
		插入数据帧编号
		发送
		启动计时器（超时重传用）
		等待确认帧
		提取确认帧
		校对确认帧{
			关闭计时器
		}
		改变下一帧的编号
	}
}


接收方：{
	初始化编号
	while（1）{
		等待
		校对数据帧{
			取帧
			上交
			发送确认帧
			编号自增
		}
	}
}
```

---
#  （重要）3.4 滑动窗口协议 

^5a6818


> 参考算法：滑动窗口

## 捎带技术 （piggybacking）
1. 双向通信
2. 双向通信的帧的种类
	1. A-B 数据帧
	2. A-B 确认帧
	3. B-A 数据帧
	4. B-A 确认帧
3. 确认帧也要有帧头，校验，控制信息和帧尾，效率低
	1. **将同方向的 （A-B ）数据帧和确认帧混合在一起**（捎带概念）
		1. 可以将确认帧暂时延缓，以便可以将确认信息搭载在下一个出境数据帧的技术
4. 优点： #考 
	1. 更好地利用信道带宽
	2. **减少**目标端的中断次数
	3. 减少单独发送确认帧带来的效率降低
5. 问题以及解决方法：
	1. 如果一个站点在收到对方数据帧之后没有数据帧发送给对方，源站可能要**超时**；
		1. （ #考 ）**采用辅助计时器方法**：接收方收到数据后，启动辅助计时器，如果辅助计时器到时，还没有反向数据传送，则**单独**发送确认帧
## 发送窗口
1. 发送窗口的最大值：一次可以连续发送而未经对方确认的帧的个数的最大值
2. 发送缓冲区：发送缓冲区的个数相当于发送窗口的最大帧的个数（固定值），发送窗口内有两类帧：
	1. 未发送：未发送而落入发送缓冲区的帧，可以连续发送出去
	2. 已发送：已发送，在缓冲区**等待确认**的帧，只有发送缓冲区的帧得到确认才能删除，窗口向前移动
3. 序列号代表了在发送缓冲区中已发送了但未确认的帧
4. 只有收到确认帧（ack）窗口才能向前移动
5. Ws：发送窗口的大小
	1. Ws = 1：停等协议
	2. Ws 非常大：连续 ARQ 协议
	3. 大小可变


> 等待处理的帧在一个数轴上，发送窗口是在数轴上的一个区间，这个区间大小固定，从下标小的向下标大的方向移动；被区间（窗口）涵盖的数（帧）能够允许连续发送，只有当最左边的帧收到确认了，区间才向右滑动，确认后的帧被移出窗口，右侧未被发送的帧加入窗口，使得能够被发送。

## 接收窗口
1. 接收窗口用于控制哪些帧可以接收，哪些不可以
	1. 只有当收到的数据帧的发送序号落入接收窗口内才允许将该帧收下，窗口向前移动一个并发送确认给对方
	2. 若接收到的数据帧落到窗口外则丢弃
2. 接收窗口 Wr：窗口大小
	1. Wr = 1：顺序接收
	2. Wr >1：可以不安顺序接收，但是提交给网络层的分组一定要**按照顺序**
	3. 一般不可变

## 滑动窗口协议

^8c580b

#考 定义
1. **由发送窗口和接收窗口控制的协议**
2. 由发送窗口来控制发送帧的数量，只有落到发送窗口的才能发送，落到接收窗口的才接收。接收端确认数据后，才移动窗口并应答，发送端收到确认后，窗口才向前
3. 接收窗口的大小固定，发送窗口是可变的
4. 发送窗口中的帧未确认时会一直存在于缓冲区中，以保证出错能够有数据重传

### 1 位滑动窗口协议（协议四）
1. 接收发送窗口都为 1 #考 
2. 退化成了**停-等**协议
3. 问题：
	1. 效率低，发送一次就要等到接收方回复
	2. 受到信号通过线路的传输时间长（时延大）的影响很大[[0名词解释/传播时延]]
### 回退 N 帧协议（协议五）
1. 发送方：
	1. 窗口有一定大小 #考 
	2. 不等待确认帧而连续发送下面的数据帧，如果收到了确认帧，则可以继续发送。若第 N 帧的确认帧超时，则从第 N 帧开始重新连续传输（go back N）
2. 接收方
	1. 窗口大小为 1
	2. 按序接收帧，接收到坏帧时，简单丢弃掉这个帧和这个帧之后的所有帧，**不发送确认帧**
		1. 因为不发送确认帧，所以发送方不知道出错了，要等到超时才认为出错，开始重传
3. 特点
	1. 效率高，发送端不需等待确认
	2. 不适用，没有考虑到接收端的处理能力，如果发生错误，对效率影响较大
	3. 连续发送若干个帧
	4. 信道利用率高
	5. 管道化技术
4. $Ws<=2^{n-1}$

### 选择性重传协议（协议六）
1. 优化方法：
	1. Wr>1：选择性重传
		1. 帧出错了，对于之后的帧接收并存储（暂存到缓冲区），等到出错帧重传之后确认了，才对这些帧排序，上传到网络层
	2. 否定的确认帧：NAK
		1. 接收了，但是出错，向发送方申请重传
2. 接收方接收到坏帧后，发送 NAK，激发发送方重传该帧，之后的帧连续接收，但是不上传，直到坏帧的重传帧确认后，再将窗口中的帧排序上传至网络层

#### 选定最大窗口值
例题：书 P187
> 帧编号是二进制编码


最大窗口值 $W<=2^{n-1}$; $n:帧编号的位数$
$$
Ws+Wr<=2^{n},
Ws>=Wr,n:序列号位数
$$
超过最大窗口值，会出现前后窗口有重叠（序号是重复使用的，第一部分的序号会和后面部分的序号重叠）


# 3.5数据链路层协议事例（自学）

## 3.5.1 sonet 上的数据包

## 3.5.2ADSL
1. Ppp 协议
2. HDLC 协议