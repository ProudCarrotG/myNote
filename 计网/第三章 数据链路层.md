
传输单位：帧 （Frame）

结点（node）： 网络中的**主机**和**路由器**

链路（link）： 通信路径上连接相邻节点的通信信道，中间没有其他的交换节点。一条链路只是一条通路的一个组成部分

数据链路（data link）： 在一根线路上传输数据，还要有一些**必要规程**控制数据传输

规程：通信**协议**

数据链路层协议：定义了一条链路的两个节点间交换数据的数据单元**格式**，以及节点发送和接收数据单元的**动作**
> 使用适配器 (网卡)来实现协议的硬件和软件
> 一般的适配器都包括了链路层和物理层的功能

点到点 (point to point): (数据链路层)
通信: 相邻节点间一条链路的通信

>端到端 (end to end): (在网络层传输层)
从源节点到目的节点的通信; 会有多条链路构成




#  3.1 

## 3.1.1 提供给网络层的服务
1. 向网络层提供一个定义良好的**服务接口**
	1. 数据链路 = 物理链路 (物理信道) + 通信规程 (协议)
	2. 三种方式
		1. **无确认的无连接服务**
			1. 定义: 源机器向目标机器发送独立的帧, 目标机器并不会对这些帧进行确认
			2. 特点: 实现不需要建立逻辑链接, 事后也不用释放逻辑链接; 不用试图去检测丢帧情况, 也不会去试图恢复丢失的帧
			3. 应用场景:
				1. 错误率很低的场合
				2. 实时通信,如语音传输 (对速度有一定要求的)
		2. **有确认的无连接服务**
			1. 定义: 发送的每个帧都需要**单独确认**. 一个帧在指定的时间间隔内没有到达, 则将再次发送该帧
			2. 特点: 没有事先建立或事后释放的逻辑链接
			3. 措施: 目标机器应该向源机器发送确认帧
				1. **接收正确的帧**:ACK
				2. **接收到错误的帧**:NAK
				3. **超时**:Resend
			4. 应用场景: 不可靠的信道, 如**无线信道**
		3. **有确认的有链接服务**  (有确认的面向连接服务)
			1. 定义: 源机器和目标机器在传输任何数据之前, 都要**建立**连接, 发送的每个帧都要被**编号**, 数据链路层确保每一个帧都会**真正被**接收方**收到**. 此外, 他还保证每个**帧只能接收一次**, 并且所有的帧都**按正确的顺序被接收**
			2. 三个阶段
				1. 建立连接
				2. 传输帧
				3. 释放连接
			3. 特点:
				1. 没有错误的帧
				2. 没有一样的帧
				3. 有顺序的
2. 处理传输错误 ---- 错误控制
	1. 物理层中传输介质的噪声, 所以错误不可避免, 交由链路层来控制错误
3. 调解数据流, 确保慢速接收方不会被快速发送方淹没----流量控制
	1. 发送方发送速度太快, 接收方来不及接收容易出错, 会导致数据丢失 ^1998 a 5

## 3.1.2 成帧
将 01 比特流打包成一段一段的.
1. 为什么成帧
	1. 提高传输效率
	2. 差错控制
2. 帧同步
	1. 以帧为单位进行传送, 指出帧的开始和结束
3. 方法:
	1. Byte count **字节计数法**
		1. 利用头部的一个字段, 来表示该帧中的字节数
			1. 只用第一个字段来表示帧的范围
		2. 计数值可能因为一个传输错误而被弄混
			1. 一个计数值错了, 后面的就会全错
	2. Flag bytes with byte stuffing **字节填充的标志字节法**
		1. 标志字节: 用一个字节"FLAG**字节**"来作为起始和结束
			1. 两个 flag 字节来框出一个帧的范围
		2. 填充字节: ESC 转义**字节**  类似于 `\n` `\\`
			1. 因为 flag 可能还会出现在帧的内容之中, 所以需要一个转义字节
	3. Flag bits with bit stuffing **比特填充的标志比特法**
		1. 方法: 每个帧的开始和结束由一个特殊的比特模式, 如 `01111110` ^8 b 15 ec
			1. 该标志比特可能会出现在帧的内容之中
		2. 填充比特: 
			1. 五个连续的 `1` 后面加 `0`
				1. 样例 1:
				2. 原始内容 `0111111011`
				3. 线路内容 `01111101011`
				4. 接收 `0111111011`
				5. 样例 2:
				6. 原始内容 `110101111101011111101011111110`
				7. 线路内容 `110101111100101111101010111110110`
				8. 线路上完整内容: 在线路内容的头和尾加上标志比特[[第三章 数据链路层#^8b15ec]]
	4. Pyysical layer coding violations

## 3.1.3 差错控制
1. 原因: 噪声
2. 错误类型:
	1. 数据帧出错
	2. 数据帧丢失
3. 噪声:
	1. 白噪声: 随机错误, 单个出现
	2. 冲击噪声: 突发错误, 密集出现
4. 措施
	1. **避错**: 采用高档设备或介质
	2. **容错**: 发生错误时, 用某种方法检测与纠正
5. 检测和纠正: 数据之外添加冗余编码
	1. 检错码: 通过编码检查能自动发现差错 ^d 46 c 40
		1. 比较简单, 出错之后直接重新传输帧
	2. 纠错码: 除了能知道出错, 还能知道错误发生的位置
		1. 更加复杂, 代价更大
6. 措施: 奇偶校验水平垂直奇偶校验, crc 校验等
	1. 奇偶校验码: 是通过增加冗余位来使得码字中 `1` 的个数保持奇数或偶数的编码方法, 是一种**检错码**   [[第三章 数据链路层#^d46c40]]
		1. 只能纠正一位错误 (错两位的话奇偶性质不变)


## 3.1.4 流量控制
1. 问题: [[第三章 数据链路层#^1998a5]]
2. 方法:
	1. 基于**反馈**的流量控制
	2. 基于**速率**的流量控制



## 主要功能
通过一些协议, 在不太可靠的物理链路上实现可靠的数据传输
1. 链路管理
2. 数据成帧
	1. 从 01 比特通过规则成帧
3. 差错控制
4. 流量控制
5. 透明传输
6. 寻址
7. (介质访问控制)(第四章)




#  3.2 差错检测和纠正
反正错误不可避免, 理由太长不计了, 大概就是介质什么的问题
## 3.2.1 (重要)检错码
1. 添加冗余信息, 接收方只能推断出有错误, 然后让发送方重传

### 奇偶校验
1. 数据后面加上**一个奇偶位**, 保证码中 `1` 的个数为偶数或奇数
2. 
### CRC


## 3.2.2 纠错码
能直接推断出错了什么

### 海明码
```
海明码（Hamming code）是一种用于检测和纠正数据传输中错误的编码技术。它是由美国数学家理查德·W·海明（Richard W. Hamming）于20世纪中期提出的，用于改进数字通信系统的可靠性。

海明码的主要目的是在数据传输过程中检测并纠正单个比特的错误。这对于在数字通信中具有重要意义，因为在数据传输过程中，由于各种原因，比特可能会出现错误。海明码可以帮助检测这些错误，并在可能的情况下自动修复它们。

海明码的工作原理如下：
1. 将要传输的数据按照一定的规则进行编码，通常会在原始数据中添加一些冗余位。
2. 编码后的数据包含了原始数据和冗余位，使得可以检测和纠正错误。
3. 在接收端，对接收到的数据进行解码，利用冗余位检测错误，如果发现错误，可以通过纠正码来修复错误。
4. 如果错误超出了码字能够纠正的范围，就需要进行重传或其他错误处理操作。

海明码的一个常见应用是在计算机内存中，以检测和纠正内存中的位错误。它还被广泛用于数字通信和数据存储系统中，提高了数据的可靠性。

不同类型的海明码可以用于不同的应用，具体的参数和纠错能力可以根据需求进行调整。这种编码技术在信息科学和通信领域中有广泛的应用。
```

#  3.3 
#  （重要）3.4 滑动窗口协议 
