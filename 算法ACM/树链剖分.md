# 树链剖分－重链剖分

## 什么是树链剖分呢？

是对一棵树进行链式剖分，将一棵树分成若干条链，常用来解决树上任意两点之间的问题，例如求两点之间的$lca$，两点之间的点权之和，两点之间的距离等

关键点在于树链剖分给树上的节点以dfs序重新进行了一次编号，这个编号的特性使得点与点之间呈一个连续的关系，让树转变成一个一维的数组来处理问题

## 重链剖分

### ”重量“

一个节点的”重量“，定义为以这个节点为根的子树节点数量，也就是说：这个节点之后的节点越多，重量越高

### 重儿子

众所周知，树上一个节点会有很多的儿子，其中**重量**最重（**子树节点**最多）的儿子被定义为重儿子，其余的节点称为亲儿子

### 重链

在树上的一条链，以某一个**亲儿子**为起点，之后的所有节点都是**重儿子**；

重链的长度会尽可能的长，而在重链分出去的其他重链长度就会不及这条重链的一半

### 怎么做

#### 第一次的dfs

根据上面的内容，我们发现想要剖分出一条链需要先知道所有节点的重儿子是谁，想要求出重儿子，需要知道子树的大小

用$son[x]$来表示$x$节点的重儿子，$sz[x]$表示以$x$为根的子树大小，$fa[x]$表示$x$的父亲，一是防止往回搜索，二是之后需要用到

```cpp
void dfs1(int u)
{
    sz[u] = 1;//sz要算上自己

    for (auto v : edge[u])
    {
        if (v == fa[u])//如果v是父亲就跳过
            continue;

        fa[v] = u;//从u走到v，则u是v的父亲
        dfs1(v); //去处理v的信息
        sz[u] += sz[v];//更新子树大小
        if (!son[u] || sz[v] > sz[son[u]])//如果没有重节点，或者当前的v比之前的重节点更重
            son[u] = v;
    }

```

这样就维护好了每个节点的重儿子和父亲

#### 第二次的dfs

开始剖分链，用$top[x]$来记录当前节点所在链的头节点，这样就可以区分出某一个节点所属的链；$dfn[x]$记录节点的dfs序

```cpp
void dfs2(int u, int tp){//tp：链的头节点
    top[u] = tp;//将当前节点加入到链中

    dfn[u] = ++idx;//更新当前节点的dfs序

    if (son[u])
        dfs2(son[u], tp);//如果存在重儿子就先去搜索重儿子

    for (auto v : edge[u]){//轻儿子
        if (v != son[u] && v != fa[u])
            dfs2(v, v);//轻儿子和当前节点不在同一条链上，以轻儿子为起点重新创建一条新链
    }

```

第二次的dfs就给每个节点分配到了一条链上，并且重新对其做了编号

### 有什么用？

树上的节点被剖分成一条条重链，重链剖分使得先出现的重链尽可能的长，而dfs序也改变成所在重链更长的节点，dfs序会更小，并且一条重链上的节点dfs序是连续的，越靠后的节点dfs序越大。

#### 链的用法

树上的链式结构使得每一个节点都可以快速的向上寻找一个标志节点，即当前重链的头节点。除了root,所有的重链头节点的父亲节点，都指向另一条重链。

求LCA时就可以将重链靠下（dfs序更大）的节点往上跳，直到两个节点在同一个重链时，靠上的节点就为lca；时间复杂度为常数很小的$O(logn)$

#### dfs序的用法

因为同一条链的的每个节点dfs序是连续递增的，所以可以用线段数/树状数组快速的求出某个节点到链头节点的区间$[dfn(top[x]), dfn[x]]$的内容，也可以对其进行修改。

可以用来快速的求出树上任意两个节点之间的路径(其实也就是  节点a－lca(a,b)－节点b)

```cpp
void qry(int u, int v)
{
    int res;
    while (top[u] != top[v]) // 跳至同一条重链
    {
        if (dfn[u] < dfn[v])
            swap(u, v); // 先跳靠后的节点

        res += get_sum(dfn[top[u]], dfn[u]); // 获得u节点到top[u]的信息，并更新res的信息

        u = fa[top[u]]; // 更新u
    }

    if (dfn[u] > dfn[v])
        swap(u, v); // 调整u，v顺序

    res += get_sum(dfn[u], dfn[v]);

    return res;
}
```

# 注意

在使用线段数或树状数组时，以dfs序为标准往数组里放数
